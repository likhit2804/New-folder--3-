import os
import sys
import json
import time
import argparse
import requests
import boto3
from botocore.exceptions import ClientError

def submit_scan(api_endpoint, iac_plan_file):
    """Submits the IaC plan to the API and returns the scan_id."""
    try:
        with open(iac_plan_file, 'r') as f:
            iac_plan = json.load(f)
    except Exception as e:
        print(f"Error: Could not read or parse JSON file {iac_plan_file}: {e}", file=sys.stderr)
        sys.exit(1)
        
    payload = {
        'iac_plan': iac_plan
        # scan_id will be generated by the submitter_lambda
    }
    
    url = f"{api_endpoint.rstrip('/')}/scans"
    
    try:
        print(f"Submitting scan to {url}...")
        response = requests.post(url, json=payload)
        response.raise_for_status()
        
        response_data = response.json()
        scan_id = response_data.get('scan_id')
        
        if not scan_id:
            print(f"Error: API response missing 'scan_id'. Response: {response.text}", file=sys.stderr)
            sys.exit(1)
            
        print(f"Scan submitted. Scan ID: {scan_id}")
        return scan_id
        
    except Exception as e:
        print(f"Error submitting scan: {e}", file=sys.stderr)
        sys.exit(1)

def poll_for_results(table_name, scan_id, timeout_seconds=300, poll_interval=10):
    """Polls the DynamoDB table for the scan result."""
    print(f"Polling for results for scan_id {scan_id} in table {table_name}...")
    
    dynamodb = boto3.resource('dynamodb')
    table = dynamodb.Table(table_name)
    
    start_time = time.time()
    while time.time() - start_time < timeout_seconds:
        try:
            response = table.get_item(Key={'scan_id': scan_id})
            item = response.get('Item')
            
            if not item:
                print("Waiting for scan to be initialized...")
                time.sleep(poll_interval)
                continue
                
            status = item.get('status')
            if status == 'COMPLETED':
                print("Scan COMPLETED.")
                return item
            elif status == 'FAILED':
                print(f"Scan FAILED: {item.get('error_message', 'Unknown error')}", file=sys.stderr)
                return item
            elif status == 'PENDING':
                print("Scan PENDING...")
            
            time.sleep(poll_interval)
            
        except ClientError as e:
            print(f"Error polling DynamoDB: {e}", file=sys.stderr)
            time.sleep(poll_interval)
        except Exception as e:
            print(f"An unexpected error occurred: {e}", file=sys.stderr)
            sys.exit(1)
            
    print(f"Error: Scan timed out after {timeout_seconds} seconds.", file=sys.stderr)
    sys.exit(1)

def analyze_results(result_item):
    """Analyzes the final item and determines the exit code."""
    status = result_item.get('status')
    if status != 'COMPLETED':
        return 1 # Exit with failure if scan did not complete
        
    results_str = result_item.get('results_json', '[]')
    skipped_feeds = result_item.get('skipped_feeds', [])
    
    try:
        findings = json.loads(results_str)
    except Exception:
        findings = []

    print("\n--- Scan Results ---")
    
    if skipped_feeds:
        print(f"‚ö†Ô∏è Warning: The following feeds were skipped: {', '.join(skipped_feeds)}")
        print("Results may be incomplete.\n")
        
    if not findings:
        print("‚úÖ No findings reported.")
        return 0 # Success

    print(f"Found {len(findings)} findings:")
    
    is_critical = False
    for finding in findings:
        risk = finding.get('risk_score', 0) # This needs to map to your scoring
        resource = finding.get('resource_name', 'unknown')
        evidence = finding.get('evidence', 'none')
        
        # This is a placeholder. Update this to use your actual risk levels
        # (CRITICAL, HIGH, etc.) once your scoring module is improved.
        if risk > 8: # Placeholder for CRITICAL
            print(f"  - üö® CRITICAL risk finding on {resource} (Score: {risk})")
            print(f"    Evidence: {evidence[:100]}...")
            is_critical = True
        else:
            print(f"  - ‚ÑπÔ∏è  Finding on {resource} (Score: {risk})")

    if is_critical:
        print("\n--- üö® ACTION REQUIRED: Critical findings detected. ---")
        return 1 # Exit with failure
    else:
        print("\n--- ‚úÖ SUCCESS: No critical findings detected. ---")
        return 0 # Exit with success

def main():
    parser = argparse.ArgumentParser(description="TA-IaC CI/CD Runner")
    parser.add_argument("--file", required=True, help="Path to the Terraform JSON plan file.")
    parser.add_argument("--api-endpoint", required=True, help="The API Gateway endpoint URL for the scanner.")
    parser.add_argument("--table-name", required=True, help="The DynamoDB results table name (e.g., TaIacScanResults-3).")
    parser.add_argument("--timeout", type=int, default=300, help="Timeout in seconds to wait for results.")
    
    args = parser.parse_args()
    
    # 1. Submit
    scan_id = submit_scan(args.api_endpoint, args.file)
    
    # 2. Poll
    final_result_item = poll_for_results(args.table_name, scan_id, args.timeout)
    
    # 3. Analyze and Exit
    exit_code = analyze_results(final_result_item)
    sys.exit(exit_code)

if __name__ == "__main__":
    # Set AWS credentials and region from environment variables
    # (e.g., AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_DEFAULT_REGION)
    main()